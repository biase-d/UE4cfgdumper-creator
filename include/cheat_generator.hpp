#pragma once

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <iomanip>
#include <unordered_map>
#include <algorithm>
#include <cctype>
#include "json.hpp"

// A struct to hold the parsed data for a single cvar from the log file
struct ParsedSetting {
    std::string main_offset;
    std::string add_offset;
    std::string type;
    std::string value; // Stores the decimal string value for int/float
    std::string hexValue; // Stores the hex string (e.g "0x42C80000")
};

// Use a map to store all parsed settings, keyed by the cvar name
using ParsedLog = std::unordered_map<std::string, ParsedSetting>;

// Helper function for case-insensitive string comparison
bool iequals(const std::string& a, const std::string& b) {
    return std::equal(a.begin(), a.end(),
                      b.begin(), b.end(),
                      [](char a, char b) {
                          return std::tolower(static_cast<unsigned char>(a)) == std::tolower(static_cast<unsigned char>(b));
                      });
}

// Helper function to trim whitespace from a string
std::string trim(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\n\r");
    if (std::string::npos == first) return "";
    size_t last = str.find_last_not_of(" \t\n\r");
    return str.substr(first, (last - first + 1));
}

/**
 * @brief Parses the log file generated by UE4cfgdumper.
 * @param log_path Path to the .log file.
 * @return A ParsedLog map containing the parsed data.
 */
ParsedLog parseLogFile(const std::string& log_path) {
    ParsedLog parsed_data;
    std::ifstream log_file(log_path);
    if (!log_file.is_open()) {
        printf("Error: Could not open log file for parsing: %s\n", log_path.c_str());
        return parsed_data;
    }

    std::string line;
    // First line is engine version
    if (std::getline(log_file, line)) {
        parsed_data["engineVersion"] = { trim(line) };
    }
    // Skip empty line
    std::getline(log_file, line);

    while (std::getline(log_file, line)) {
        line = trim(line);
        if (line.empty()) continue;

        try {
            std::stringstream ss(line);
            std::string token;

            std::getline(ss, token, ',');
            std::string cvar = trim(token);

            std::getline(ss, token, ',');
            std::stringstream offset_ss(token);
            std::string main_offset_str, main_offset_val, plus_sign, add_offset_val;
            offset_ss >> main_offset_str >> main_offset_val >> plus_sign >> add_offset_val;

            std::getline(ss, token);
            std::stringstream type_ss(token);
            std::string type_str, type_val, value_val, slash, hex_val;
            type_ss >> type_str >> type_val >> value_val >> slash >> hex_val;

            ParsedSetting setting;
            setting.main_offset = main_offset_val;
            setting.add_offset = add_offset_val;
            setting.type = type_val;
            setting.value = value_val;
            setting.hexValue = hex_val;

            parsed_data[cvar] = setting;
        } catch (const std::exception& e) {
            printf("Warning: Could not parse log line: %s\n", line.c_str());
        }
    }

    log_file.close();
    printf("Successfully parsed log file.\n");
    return parsed_data;
}

/**
 * @brief Generates a cheat file from parsed log data and a JSON config.
 * @param log_data The parsed data from the log file.
 * @param config_path Path to the config.json file.
 * @param output_path Path for the generated cheat .txt file.
 */
void generateCheatsFromConfig(const ParsedLog& log_data, const std::string& config_path, const std::string& output_path) {
    std::ifstream config_file(config_path);
    if (!config_file.is_open()) {
        printf("Error: Could not open config file: %s\n", config_path.c_str());
        return;
    }

    nlohmann::json config;
    try {
        config = nlohmann::json::parse(config_file);
    } catch (const nlohmann::json::parse_error& e) {
        printf("Error: Failed to parse config.json: %s\n", e.what());
        return;
    }
    config_file.close();

    std::stringstream cheat_stream;

    bool use_categories = false;
    std::string default_indicator = "";

    if (config.contains("config") && config["config"].is_array() && !config["config"].empty()) {
        const auto& global_config = config["config"][0];
        if (global_config.contains("categories")) use_categories = global_config["categories"];
        if (global_config.contains("defaultIndicator")) default_indicator = global_config["defaultIndicator"];
    }

    for (auto const& [category, settings] : config.items()) {
        if (category == "config") continue;

        if (use_categories) {
            cheat_stream << "[--SectionStart:" << category << "--]\n";
            cheat_stream << "00000000 00000000 00000000\n";
        }

        for (const auto& setting : settings) {
            std::vector<std::pair<std::string, std::string>> filtered_options;
            bool is_default = true;

            for (const auto& option : setting["options"]) {
                for (const auto& [name, value] : option.items()) {
                    if (log_data.count(name)) {
                        filtered_options.push_back({name, value});
                        const ParsedSetting& parsed_setting = log_data.at(name);

                        // Extract the first hex value from the config string "HEX1 HEX2"
                        std::string config_hex_val_str;
                        std::stringstream val_ss(value.get<std::string>());
                        val_ss >> config_hex_val_str;

                        // Remove "0x" prefix from log's hex value for comparison
                        std::string parsed_hex = parsed_setting.hexValue;
                        if (parsed_hex.rfind("0x", 0) == 0) {
                            parsed_hex = parsed_hex.substr(2);
                        }

                        if (!iequals(config_hex_val_str, parsed_hex)) {
                            is_default = false;
                        }
                    }
                }
            }

            if (!filtered_options.empty()) {
                std::string cheat_name = is_default ? default_indicator + " " + setting["name"].get<std::string>() : setting["name"].get<std::string>();
                cheat_stream << "[" << cheat_name << "]\n";

                for (const auto& option : filtered_options) {
                    const std::string& name = option.first;
                    const std::string& value_str = option.second;
                    const ParsedSetting& parsed_setting = log_data.at(name);

                    if (!parsed_setting.main_offset.empty()) {
                        std::string main_offset_hex = parsed_setting.main_offset;
                        if (main_offset_hex.rfind("0x", 0) == 0) main_offset_hex = main_offset_hex.substr(2);

                        std::string add_offset_hex = parsed_setting.add_offset;
                        if (add_offset_hex.rfind("0x", 0) == 0) add_offset_hex = add_offset_hex.substr(2);

                        std::transform(main_offset_hex.begin(), main_offset_hex.end(), main_offset_hex.begin(), ::toupper);
                        std::stringstream main_offset_ss;
                        main_offset_ss << std::setw(8) << std::setfill('0') << main_offset_hex;

                        cheat_stream << "580F0000 " << main_offset_ss.str() << "\n";

                        if (add_offset_hex != "0") {
                            std::transform(add_offset_hex.begin(), add_offset_hex.end(), add_offset_hex.begin(), ::toupper);
                            std::stringstream add_offset_ss;
                            add_offset_ss << std::setw(8) << std::setfill('0') << add_offset_hex;
                            cheat_stream << "780F0000 " << add_offset_ss.str() << "\n";
                        }

                        cheat_stream << "680F0000 " << value_str << "\n";
                    }
                }
            }
        }

        if (use_categories) {
            cheat_stream << "[--SectionEnd:" << category << "--]\n";
            cheat_stream << "00000000 00000000 00000000\n";
        }
    }

    std::ofstream out_file(output_path);
    if (out_file.is_open()) {
        out_file << cheat_stream.str();
        out_file.close();
        printf("Generated cheat file at: %s\n", output_path.c_str());
    } else {
        printf("Error: Could not open output file for writing: %s\n", output_path.c_str());
    }
}
